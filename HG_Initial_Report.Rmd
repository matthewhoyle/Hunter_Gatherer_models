---
title: "Modelling the persistence of infectious diseases in pre-agricultural Hunter-gatherers"
subtitle: "Initial Report"
author: "Matthew Hoyle"
output: html_notebook
---
## Set-up
```{r}
rm(list = ls())
library(dplyr)
library(wesanderson)
```

## Model Parameter estimation

### Agta Hunter-Gatherer Demography

Information regarding births, deaths and population size were obtain from a study conducted by Headland et al., (2011). Authors conducted a census-like survey of the 
```{r}
agta_demo <- read.csv("AgtaPopDynamics_Headland2007.csv")

ggplot(agta_demo, aes(x=Year)) +
  geom_line(aes(y=PopSize), colour = wes_palettes$Darjeeling1[1]) +
  geom_line(aes(y=Births), colour = wes_palettes$Darjeeling1[2]) +
  geom_line(aes(y=Deaths), colour = wes_palettes$Darjeeling1[3]) +
  theme_bw()
```

#### Population Size
```{r}
hist(agta_demo$PopSize)
summary(agta_demo$PopSize)
```

#### Births
```{r}
hist(agta_demo$Births)
summary(agta_demo$Births)
```

#### Deaths
```{r}
hist(agta_demo$Deaths)
summary(agta_demo$Deaths)
```

#### Birth/Death rate per 1,000
```{r warning=FALSE}
agta_demo <- agta_demo %>%
  mutate(Birth_rate = (Births/PopSize),
         Birth_rate_daily = (1 + Birth_rate) ^ (1/365) - 1,
         Death_rate = (Deaths/PopSize),
         Death_rate_daily = (1 + Death_rate) ^ (1/365) - 1,
         BD_rate = (Births - Deaths)/PopSize,
         BD_rate_daily = (1 + BD_rate) ^ (1/365) - 1,
         PopChange = (diff = PopSize - lag(PopSize, default = first(PopSize))),
         PopChange_rate = abs(PopChange)/PopSize,
         PopChange_rate_daily = (1 + PopChange_rate) ^ (1/365) - 1)
head(agta_demo)


hist(agta_demo$Birth_rate)
hist(agta_demo$Death_rate)

ggplot(agta_demo, aes(x=Year)) +
  geom_line(aes(y=Birth_rate), colour = wes_palettes$Darjeeling1[2]) +
  geom_line(aes(y=Death_rate), colour = wes_palettes$Darjeeling1[3]) +
  theme_bw()

sum_table <- agta_demo %>%
  select(PopSize, Birth_rate, Birth_rate_daily, Death_rate, Death_rate_daily, BD_rate, BD_rate_daily, PopChange_rate, PopChange_rate_daily) %>%
    summarise(across(
    .cols = is.numeric, 
    .fns = list(Mean = mean, SD = sd), na.rm = TRUE, 
    .names = "{col}_{fn}"
    ))
sum_table 

sum_list <- as.list(sum_table)
```

## *Mycobacterium Tuberculosis*

To first observe the dynamics 

### Single Population Model

Time-interval of years currently being used
```{r}
library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     500000 #53    # Patch size
initial_infected <-  1    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 12*50                                    # Final time

#Collect parameters
parms <- list(
  beta = 0.0253,          # probability of infection given contact ()
  sigma = 0.000249,                          # E to I rate
  gamma = 0.0188,                           # I to R rate
  omega = 0.00,                         # R to S rate
  mu =  3.41e-05,       # Birth rate per person per day (Ask tom is this should be taken from distribution or just use mean)
  phi = sum_list$Death_rate_Mean,      # Death rate
  alpha = 0) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
#set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 



## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()
```


```{r}
## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

extinct_data
```


```{r}
print("R0 = ")
R0

print("Actual number of infecteds at end of sim =")
sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches

print("Expected number of infecteds at equilibrium = ")
expected_infected


```



### Metapopulation Models
On yearly scale
```{r}
library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(rep(100,20))    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 365*50                                   # Final time


#Collect parameters
parms <- list(
  sigma = 0.0024,                          # E to I rate
  gamma = 0.0018,                           # I to R rate
  omega = 0.00,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 

# Define transmission terms and populate next-generation matrix
beta = 0.0017

within_pop_contact = 0.27
between_pop_contact = hist(rgamma(100, 0.1, 0.1))     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 




#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
)


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 3, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot
```


```{r}
## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)
extinct_data
```


```{r}
print("R0 = ")
R0

print("Actual number of infecteds at end of sim =")
sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches

sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}

```





## SARS-CoV-2

### Single Population Model
```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     53    # Patch size
initial_infected <- 1    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time

#Collect parameters
parms <- list(
  beta = 0.6,
  sigma = 0.175,                          # E to I rate
  gamma = 0.2,                           # I to R rate
  omega = 1/90,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.0097) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```
### Metapopulation Model
```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(rep(53,10))    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                   # Final time


#Collect parameters
parms <- list(
  sigma = 0.175,                          # E to I rate
  gamma = 0.2,                           # I to R rate
  omega = 1/90,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.0097) 

# Define transmission terms and populate next-generation matrix
  beta = 0.6

within_pop_contact = 1
between_pop_contact = 0.5     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 




#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
)


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 3, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot
```


```{r}
## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)
extinct_data
```


```{r}
print("R0 = ")
R0

print("Actual number of infecteds at end of sim =")
sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches

sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}

```

## Measles 
###Single-Population Model
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(53)    # Patch size
initial_infected <- c(  1)    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time

#Collect parameters
parms <- list(
  beta = 2,
  sigma = 1/6,                          # E to I rate
  gamma = 1/6,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.00) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```

### Meta-Population model

```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(500, 200, 100, 100)    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(  
  sigma = 1/6,                          # E to I rate
  gamma = 1/6,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.00)

# Define transmission terms and populate next-generation matrix
  beta = 2

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


# Calculate expected infecteds at equilibrium (function only applies to single population system but should investigate for meta)
EIE <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EIE(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

## How does actual number of infecteds at end of sim compare with 
sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected

sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```

## Herpes Simplex Virus 2
### Single Population Model
Time step = 1 year
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(53)    # Patch size
initial_infected <- c(  1)    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time

#Collect parameters
parms <- list(
  beta = 0.0391,
  sigma = 1/0.0164,                          # E to I rate
  gamma = 0,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```


### Metapopulation

```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(500, 200, 100, 100)    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 1/0.0164,                          # E to I rate
  gamma = 0,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 

# Define transmission terms and populate next-generation matrix
    beta = 0.0391

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


# Calculate expected infecteds at equilibrium (function only applies to single population system but should investigate for meta)
EIE <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EIE(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

## How does actual number of infecteds at end of sim compare with 
sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected

sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```
## Ebola
### Single Population 
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(53)    # Patch size
initial_infected <- c(  1)    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time

#Collect parameters
parms <- list(
  beta = 0.33,
  sigma = 1/5.3,                          # E to I rate
  gamma = 1/5.6,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.5) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```

### Meta-Population
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(500, 200, 100, 100)    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 1/5.3,                          # E to I rate
  gamma = 1/5.6,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.5) 

# Define transmission terms and populate next-generation matrix
  beta = 0.33

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)



sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```

## Smallpox
### Single Population
```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(53)    # Patch size
initial_infected <- c(  1)    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time

#Collect parameters
parms <- list(
  beta = 0.696,
  sigma = 0.0685,                          # E to I rate
  gamma = 0.116,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.15) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 




## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```

### Metapopulation
```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(500, 200, 100, 100)    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 0.0685,                          # E to I rate
  gamma = 0.116,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0.15) 

# Define transmission terms and populate next-generation matrix
  beta = 0.696

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)



sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```

## Hepatitis B
Time-step = years
### Single Population


```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(53)    # Patch size
initial_infected <- c(  1)    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 10                                    # Final time


#Collect parameters
parms <- list(
  beta = 39.3,
  sigma = 10,                          # E to I rate
  gamma = 8.3,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(2)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```

### Metapopulation
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(500, 200, 100, 100)    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 10,                          # E to I rate
  gamma = 8.3,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 

# Define transmission terms and populate next-generation matrix
  beta = 39.3

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)



sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```
## 1918 Pandemic Influenza A (H1N1)
### Single Population 
```{r}
rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     53    # Patch size
initial_infected <- 1    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                   # Final time

#Collect parameters
parms <- list(
  beta = 0.73,
  sigma = 0.52,                          # E to I rate
  gamma = 0.24,                           # I to R rate
  omega = 0,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(1)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```
### Metapopulation
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(rep(53,4))    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 0.52,                          # E to I rate
  gamma = 0.24,                           # I to R rate
  omega = 1/365*4.87,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 

# Define transmission terms and populate next-generation matrix
 beta = 0.73

within_pop_contact = 1
between_pop_contact = 0.5/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 1, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)



sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```
## Seasonal Influenza
### Single Population
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     53    # Patch size
initial_infected <- 1    # Initial infected
U <- length(patchPopSize)                    # Number of patches
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                   # Final time

#Collect parameters
parms <- list(
  beta = 0.9,
  sigma = 0.67,                          # E to I rate
  gamma = 0.33,                           # I to R rate
  omega = 1/365,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 


# Calculate R0 and expected number of infecteds at equilibrium
R0 <- (1/parms$gamma) * parms$beta

EEI <- function(R0, Infectiousness_recip, Immunity_recip) {
  y = ((R0 - 1) * Immunity_recip) / (Infectiousness_recip * R0)
  return(y)
}

expected_infected = EEI(R0 = R0, Infectiousness_recip = parms$gamma, Immunity_recip = parms$omega) * sum(patchPopSize)


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      j <- if (patch == 1) U else patch - 1
      c(
        paste0("(beta*I", i,"/N", i, ")*S",i), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method
set.seed(1)
out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  labs(x="Time",
       y="Frequency")+
  geom_hline(yintercept = expected_infected, linetype = 'dashed') +
  theme_bw()

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)

sum(extinct_data$count) # Total number of infecteds at the end of sim across all patches
expected_infected


```
### Metapopulation Model
```{r}

rm(list = ls())

library(GillespieSSA)
library(tidyverse)

# Define Paramenters
patchPopSize <-     c(rep(53, 4))    # Patch size
U <- length(patchPopSize)                    # Number of patches
initial_infected <-  as.vector(rmultinom(1, 1, rep(0.5, U)))   # Initial infected (initial infected patch randomly generated)
initial_infected_patch <- which(initial_infected > 0)
simName <- "SIRS metapopulation model"       # Simulation name
tf <- 500                                    # Final time


#Collect parameters
parms <- list(
  sigma = 0.67,                          # E to I rate
  gamma = 0.33,                           # I to R rate
  omega = 1/365,                         # R to S rate
  mu = 3.41e-05,                            # Birth/death rate per person per day
  alpha = 0) 

# Define transmission terms and populate next-generation matrix
  beta = 0.9

within_pop_contact = 1
between_pop_contact = 0.25/U     # normalised by number of patches 

nextgen_matrix <- matrix(nrow = U, ncol = U, data = 0)

for(i in 1:U){
  for(j in 1:U){
    parms[[paste0("beta_",i,i)]] = within_pop_contact*beta
    nextgen_matrix[i,i] = within_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,i)]] = between_pop_contact*beta
    nextgen_matrix[j,i] = between_pop_contact*beta*(1/parms$gamma)
    nextgen_matrix[i,j] = between_pop_contact*beta*(1/parms$gamma)
    parms[[paste0("beta_",j,j)]] = within_pop_contact*beta
    nextgen_matrix[j,j] = within_pop_contact*beta*(1/parms$gamma)
  }
  parms[[paste0("N", i)]] = patchPopSize[i]
}


# Calculate R0 from NGM

eigenvalues <- eigen(nextgen_matrix, only.values = T)

R0 <- max(abs(eigenvalues$values)) 


#Create the named initial state vector for the U-patch system.

x0 <- unlist(lapply(
  seq_len(U), 
  function(i){ 
    c(patchPopSize[i] - initial_infected[i], initial_infected[i], 0, 0, patchPopSize[i])
  }
))

names(x0) <- unlist(lapply(seq_len(U), function(i) paste0(c("S","E","I", "R", "N"), i)))


# Define the state change matrix for a single patch
nu <- matrix(c( -1,  0,  0, +1, +1, -1,  0,  0,  0,  0, # S
                +1, -1,  0,  0,  0,  0, -1,  0,  0,  0, # E
                 0, +1, -1,  0,  0,  0,  0, -1,  0, -1, # I
                 0,  0, +1, -1,  0,  0,  0,  0, -1,  0, # R 
                 0,  0,  0,  0, +1, -1 ,-1, -1, -1, -1), # N
             nrow=5,byrow=TRUE)

# Define propensity functions
# Mass-action
a <-
  unlist(lapply(
    seq_len(U),
    function(patch) {
      i <- patch
      patches <- 1:U
      #j <- if (patch == 1) U else patch - 1
      other_patches <- patches[-i]
      patch_beta <- c()
      for(k in (1:(U-1))){
        patch_beta[k] = paste0("+(beta_", other_patches[k],i, "*I", other_patches[k], "/N", other_patches[k], ")*S", i)
      }
      c(
        paste0("(beta_", i, i, "*I", i,"/N", i, ")*S",i, paste0(patch_beta, collapse="")), # Infection
        paste0("sigma*E", i),                                       # Becomes infecious
        paste0("gamma*I", i),                                       # Recovery from infection
        paste0("omega*R", i),       # Loss of immunity
        paste0("mu*N", i),                             # Births
        paste0("mu*S", i),                                             # Deaths (S)
        paste0("mu*E", i),                                             # Deaths (E)
        paste0("mu*I", i),                                             # Deaths (I)
        paste0("mu*R", i),                                             # Deaths (R)
        paste0("alpha*I", i)                                           # Deaths from infection
        
      )
    }
  ))

# Run simulations with the Direct method

out <- ssa(
  x0 = x0,
  a = a,
  nu = nu,
  parms = parms,
  tf = tf,
  method = ssa.d(),
  simName = simName,
  verbose = FALSE,
  consoleInterval = 1
) 


## Extra Plots
plot_data <- out$data %>%
  as_tibble() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N"))) %>%
  filter(state != "N")

extra_plot <- ggplot(data = plot_data, aes(x=t, y=count, colour=state))+
  geom_line()+
  facet_wrap(~factor(patch, levels = unique(patch)) ,ncol = 2, scales = "free_y")+
  labs(x="Time",
       y="Frequency")+
  theme_bw()
extra_plot

## Table showing extinction/transmission info for each patch

extinct_data <- out$data %>%
  as_tibble() %>%
  slice_max(t) %>%
  distinct() %>%
  pivot_longer(!t, names_to = "ID", values_to = "count") %>%
  separate(ID, 
           into = c("state", "patch"), 
           sep = "(?<=[A-Za-z])(?=[0-9])") %>%
  mutate(state = factor(state, levels = c("S", "E", "I", "R", "N")),
         persist = case_when(state=="I" & count > 0 ~ T, 
                             state=="I" & count == 0 ~ F)) %>%
  drop_na() %>%
  select(patch, count, persist)



sim_endpoint <- as.tibble(out$data) %>%
  slice_max(t) %>%
  distinct()


print("Did simulation run reach final endpoint?")
if (sim_endpoint$t >= tf) {
  print("Yes")
} else {
  print("No")}


```

